<div align="center">
    <h1>Camp 3: StarkNet</h1>

|Presentation|Video|Try what you learned
|:----:|:----:|:----:|
|[September 2022](https://drive.google.com/file/d/1_AQq4ulTmB0VAszmauvYUHEVjwdAgMim/view?usp=sharing)|StarkNet Basecamp [p1 (September 2022)](https://drive.google.com/file/d/1w9ysR38Dz4Z9gvHC46xSHbr06B36nUWp/view?usp=sharing), [p2 (September 2022)](https://drive.google.com/file/d/185MMFmItlOE5qER8P2vhtVjKiH6Glj1G/view?usp=sharing)|Make your own [Messaging Bridge](https://github.com/starknet-edu/starknet-messaging-bridge). Test your [Account Abstraction capacity](https://github.com/starknet-edu/starknet-accounts)|

</div>

### Topics

<ol>
    <li><a href="#blocks">Blocks</a></li>
    <li><a href="#tx_lifecycle">The Lifecycle of Transactions</a></li>
    <li><a href="#starknet_os">StarkNet OS</a></li>
    <li><a href="#state">State Transition/Fees</a></li>
    <li><a href="#validation">Validation</a></li>
    <li><a href="#accounts">Account Contracts</a></li>
    <li><a href="#aa">Account Abstraction</a></li>
    <li><a href="#l1l2">L1-L2 Messaging</a></li>
</ol>

<h2 align="center" id="blocks">Blocks</h2>

<h2 align="center" id="tx_lifecycle">The Lifecycle of Transactions</h2>

On StarkNet Alpha the two types of transactions are `DEPLOY` or `INVOKE`. They go through the following lifecycle as they are submitted from the clients to the sequencer:

<div align="center">
    NOT_RECEIVED -> RECEIVED -> PENDING -> REJECTED || ACCEPTED_ON_L2 -> ACCEPTED_ON_L1
</div>


<h2 align="center" id="starknet_os">StarkNet OS</h2>

The StarkNet OS is the Cairo program that runs StarkNet. The OS handles everything which is done on the network â€” contract deployment, transaction execution, L1<>L2 messages and more.

<h2 align="center" id="state">State Transition/Fees</h2>

<h2 align="center" id="starknet_os">Validation</h2>

The private keys are at the heart of all user interaction with Ethereum. Each account address of Externally Owned Accounts is derived from a private key; there is a one-to-one relationship between a private key and an Ethereum account address. The private keys are never transmitted with messages, only the account addresses and digital signatures (also created by the private key). Ethereum transactions require a valid digital signature to be included in the blockchain. An Ethereum address for an EOA is generated from the public key portion of a key pair.

"Public key cryptography uses unique keys to secure information. These keys are based on mathematical functions that have a special property: it is easy to calculate them, but hard to calculate their inverse. Based on these functions, cryptography enables the creation of digital secrets and unforgeable digital signatures, which are secured by the laws of mathematics." ([Ethereum Book](https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc))

In Ethereum we use elliptic curve cryptography:
"A more advanced category of mathematical functions that is useful in cryptography is based on arithmetic operations on an elliptic curve. In elliptic curve arithmetic, multiplication modulo a prime is simple but division (the inverse) is practically impossible. This is called the discrete logarithm problem and there are currently no known trapdoors. Elliptic curve cryptography is used extensively in modern computer systems and is the basis of Ethereumâ€™s (and other cryptocurrencies') use of private keys and digital signatures." ([Ethereum Book](https://github.com/ethereumbook/ethereumbook/blob/develop/04keys-addresses.asciidoc))

* A private key is a number generated randomnly. Pick randomnly a number between picking a number between 1 and 2 at 256. However, we need to find a secure source of randomness.
* The private key controls access by being the unique piece of information needed to create digital signatures, which are required to sign transactions to spend any funds in the account. Digital signatures are also used to authenticate owners or users of contracts. So private keys can generate public keys, that in turn generate the address of an EOA.
* The digital signature created by the private key can sign any message. Digital signature: generated by the transaction details (message) plus the private key. In other words, only those with access to the private key can generate the digital signature for a certain transaction.
* When an EOA contract sends a transaction, it sends it the digital signature.

Notice private keys are only used to create digital signatures for transaction authentication. They are not used to encrypt messages of information sent to the blockchain since we need everyone to be able to read the information on the network.

* The public key is a point on an elliptic curve, meaning it is a set of x and y coordinates that satisfy the elliptic curve equation. In simpler terms, an Ethereum public key is two numbers, joined together. These numbers are produced from the private key by a calculation that can only go one way. That means that it is trivial to calculate a public key if you have the private key, but you cannot calculate the private key from the public key.
* Ethereum uses the exact same elliptic curve, called secp256k1, as Bitcoin.
* For example, the following is a point Q with coordinates (x,y) that is a point on the secp256k1 curve:

Q =
(49790390825249384486033144355916864607616083520101638681403973749255924539515,
59574132161899900045862086493921015780032175291755807399284007721050341297360)



<h2 align="center" id="accounts">Accounts</h2>

<h2 align="center" id="aa">Account Abstraction</h2>

**Disclaimers: This tutorial cites various stakeholders, any errors or misunderstandings in this tutorial are the fault of interpretation.*

* Most Ethereum users use centralized exchanges because managing a self-custody wallet is difficult; this is not self-custody. The current status quo risks making the next wave of users dependent on centralized exchanges ([Julien, Devcon 6](https://www.youtube.com/watch?v=OwppworJGzs)).
* The imminent arrival of quantum computers will force the cryptographic ecosystem to move to quantum-proof signatures. The stark curve is one way it can be done.

In 5 years it would be bizarre that we used to secure our assets by writing 12 words on paper. StarkNet is leading the way in implementing AA at the protocol level (not at the application level as with current EIPs on L1): it is the "proving ground" for what AA will look like in the future ([AA Panel, Devcon 6](https://app.devcon.org/schedule/9mvqce)).


### What is Account Abstraction?

> Definition 1: AA is when a **smart contract can pay for its own transactions** ([Martin Triay, Devcon 6](https://www.youtube.com/watch?v=Osc_gwNW3Fw)). In other words, abstract contracts (or account smart contracts) can pay for transactions. Note, it is not the same as Externally Owned Accounts or Smart Wallets.

> Definition 2: AA is **validation abstraction**. In L1 there is only one way to validate transactions (retrieve an address from a signature, look at that address in the state, determine if the nonce is OK for the transaction that was sent and if the account has enough balance to perform the transaction). With AA, you **abstract the validation process**: use different types of signatures, cryptographic primitives, execution processes, etc. ([lightclient, Devcon 6](https://app.devcon.org/schedule/9mvqce)).

**Note: In computing, the term abstraction is used to generalize something. In this case, we are generalizing smart contracts: from the existence of Externally Owned Contracts (EOA) and Contract Accounts (CA) to simply smart contracts.*


### So what?

According to:
* Martin Triay (Open Zeppelin), AA means [huge improvements in onboarding, user experience, and security](https://www.youtube.com/watch?v=Osc_gwNW3Fw). AA is the future of crypto UX and security.
* Julien Niset (Argent), AA means scaling self-custody which is [a requirement for onboarding the next billion users](https://www.youtube.com/watch?v=OwppworJGzs).
* Vitalik, [smart wallets should be the default](https://app.devcon.org/schedule/9mvqce) and AA is the key step. 
* Yoav (Ethereum Foundation), [AA is key for security](https://app.devcon.org/schedule/9mvqce).
  

###  Self-custody: own the keys, own the assets

Self-custody is hard and necessary. Crypto is about digital ownership: you own your assets. The principle is normally depicted with the motto: not your keys not your asset. The principle is great. However, humans will always lose and forget passwords ([Julien, Devcon 6](https://www.youtube.com/watch?v=OwppworJGzs)). From experts to beginners, everyone looses their passwords or keys. It is as true since web2 and will keep being truth in web3. Julien goes as far as saying that "ordinary users should never handle key management, and if Ethereum doesnâ€™t transition away from EOAs weâ€™ll live in a world where only the few use self-custody and the rest use centralized exchanges" ([2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)). 

In Ethereum, and other L1s, users lose their keys and recovery phrases; and that is it, the user can not recover her account's assets. There is no "I forgot my keys, help me recover my account." Whose idea was that the private key was a hard requirement? According to [Julien](https://www.youtube.com/watch?v=OwppworJGzs), the problem is at the heart of the EVM (Ethereum Virtual Machine). We will go back to this later. With AA the private key will soon be a thing of the past. 


### Use cases (some of them, invent one!)
AA promises to put programmability into every Ethereum wallet, and unlock new frontiers for both developers and users ([AA Panel, Devcon 6](https://app.devcon.org/schedule/9mvqce)). 

Among other things, AA allows:
* Social recovery: In case a user's private key is lost or compromised, AA allows wallets to add mechanisms to securely replace the key controlling the account. Never worry about seed phrases again ([Julien Niset, 2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/))!
* Key rotation: If your keys are compromised, instead of moving all the assets, you can rotate the keys and that is it. (XXX look more about this)
* Session keys: Signing with your face or finger to your cellphone or your favorite apps is possible with AA. Session keys are a set of permissions given to a website so, for example, you can sign in once and then the website can act on our behalf without you having to sign each time each transactions. This is Web2 experience.
* Guardians: XXX
* Custom transaction validation schemes.
  * Different signature schemes: You can use ethereum signatures, Bitcoin signatures, both if you want. The user could prefer a more gas-efficient signature, or a quantum-resistant one.  Use the secure enclave of iOS and Android devices to turn every phone into a hardware wallet ([Martin Triay (Devcon 6)](https://www.youtube.com/watch?v=Osc_gwNW3Fw), [Julien (2022)](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)).
  * Multisignature: Change who can sign each week. Support fraud monitoring; inspect every transaction to make sure it complies to defined security rules, and prevent users from sending assets to a scam address or incorrect contract. ([Martin Triay (Devcon 6)](https://www.youtube.com/watch?v=Osc_gwNW3Fw), [Julien (2022)](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction)).

These are just some ideas. More is still to come.

### Security

There are my ways AA helps security in Ethereum. The following were mentioned by [Yoav at Devcon 6](https://app.devcon.org/schedule/9mvqce):

* Key management: Being able to add devices to your wallet so your wallet is not associated with the seed phrase, but if you loose your ohone you can access with your computer. This improves security,
* Different signature and validation schemes: You could, for example, spend small amounts freely but if you are sending a large amount the dapp or wallet could ask for another type of signature similar to 2 Factor Authorization. This is common in centralized excahnges. 
* Different security policies for different types of users: With EOAs (L1) we only have a single policy; if you have the key then do anything if you do not have it then you can not do anything. With AA, for example, we could create a security scheme for enterprise accounts and another one for individual users. Again, copy good practices in the banking and web2 sector.
* Different security policies for different devices: For example, a phone can send a maximum amount of tokens and a computer there is a limit un less you validate in some way (2FA). For this to happen we need to be able to implement different signature schemes according to each device (e.g., a computer does not use the same curve as an android phone). The EOAs support only a type of curve which is incompatible with most devices. With AA you can use several devices with the same account. Users will not longer have a different wallet on each device; one for the computer, one for the phone, one for the Ledger. 

### Why has it not been implemented in Ethereum's L1 yet?

According to Julien Niset ([2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)), the key is to eliminate EOAs. No EIP has yet addressed this. It is understandable since this would implicate multiple changes to the heart of the protocol; and day by day, as the value secured by Ethereum increases, implementing AA gets more difficult due to the coordination required ([Julien Niset, 2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)).

If it is so important, then why does Ethereum already supports it? This is an example of the limitations of the EVM that can be surpased by a new Virtual Machine such as the Cairo VM. Proposals to implement AA have been made since the early days of Ethereum and they have constantly been "repeatedly pushed back in favour of more urgent changes." ([Julien Niset, 2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)). It is uncertain it will be implemented in next Ethereum versions even after the Merge.

The creation of new L2 VMs focused on scalability allowed for advances in its implementation; StarkNet and ZKSync have native AA inspired by EIP4337, considered the best proposal by experts such as Argent's Julien Niset ([2022](https://www.argent.xyz/blog/part-2-wtf-is-account-abstraction/)). It seems as if key proponents of AA, like Julien, have lost hope that EOAs are eliminated and AA is implemented at the core of Ethereum; Argent is now pushing for the widespread adoption of AA trough L2s like StarkNet.

### Devcon 6

AA was one of the hottest topics at Devcon 6 (2022). There were at least 6 talks, workshops and panels (one of them with Vitalik) on the subject. Of these two were addressed directly from AA on StarkNet, and they all acknowledge AA on StarkNet.
* [Martin Triay, Open Zeppelin: Account Abstraction in StarkNet](https://www.youtube.com/watch?v=Osc_gwNW3Fw) (StarkNet oriented).
* [Vitalik Buterin, David Hoffman (Bankless), Julien Niset (Argent), Yoav Weiss (Ethereum Foundation), lightclient (Geth): Account Abstraction Panel](https://www.youtube.com/watch?v=WsZBymiyT-8&feature=emb_imp_woyt).
* [Liraz, Yoav Weiss (Ethereum Foundation): ELI5: Account Abstraction](https://www.youtube.com/watch?v=QuYZWJj65AY).
* [(ETH Global) Yoav Weiss (Ethereum Foundation), Dror Tirosh: Ethereum Foundation ðŸ›  Account abstraction: building an ERC-4337 wallet](https://www.youtube.com/watch?v=xHWlJiL_iZA).
* [Dror Tirosh, Liraz: Account Abstraction: Making Accounts Smarter](https://app.devcon.org/schedule/nz3pyp).
* [Ivo Georgiev, Ambire Wallet: The Future of Wallets: MPC vs Smart Wallets](https://archive.devcon.org/archive/watch/6/the-future-of-wallets-mpc-vs-smart-wallets/?tab=YouTube).
* [Danno Ferrin, Hedera Hashgrap: What Alternative Blockchains Compatibility with Ethereum Tooling Can Teach Us About Ethereum's Future](https://www.youtube.com/watch?v=KqE9HN4QGpM).
  

### AA is already here, enjoy! 

Now that we know better the concept of AA, let's actually code it in StarkNet.

As it was mentioned before, StarkNet possess AA natively. The design has been notably led by Starkware, Open Zeppellin, and Argent.

### The proccess

We will perform **counterfactual deployment**. That is:

1. Calculate the account contract's address before deployment.

A contract address in the StarkNet network is a unique identifier of the contract and is a hash of (more details in [the documentation](mentation/develop/Contracts/contract-address/) and [actual implementation in Python](https://github.com/starkware-libs/cairo-lang/blob/13cef109cd811474de114925ee61fd5ac84a25eb/src/starkware/starknet/core/os/contract_address/contract_address.py#L40)):
* Prefix - the ASCII encoding of the string â€œSTARKNET_CONTRACT_ADDRESSâ€.
* Deployer address - currently always zero.
* Salt - random number (felt) used to distinguish between different instances of the contract.
* Class hash - hash chain of the definition of the class (more [here](https://docs.starknet.io/documentation/develop/Contracts/contract-hash/)).
* Constructor calldata hash - array hash of the inputs to the constructor.

This means we can calculate the contract address of the account contract we want to deploy even before deploying. This is what we do when we initialize an account contract:

```Bash
starknet new_account --network alpha-goerli --account ALIAS --wallet starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
```

This yields something like:

```Bash
Account address: 0x006b27f2455d175f1c9b39568838ee0c1dfba34ca29f489690e40ee69220f15c
Public key: 0x07f90c757da3498bfa61b393e1048ace09d9729f9fc75d2a5dc6eb590852643e
Move the appropriate amount of funds to the account, and then deploy the account
by invoking the 'starknet deploy_account' command.

NOTE: This is a modified version of the OpenZeppelin account contract. The signature is computed
differently.
```

Now we have the account contract's address (([this is the line](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/wallets/open_zeppelin.py#L107) where the address is calculated in the repo)) that we can fund; if using the testnet we can use the [faucet](https://faucet.goerli.starknet.io/). We are using the default account contract structure created by Open Zeppelin (a bit modified) which you can find in the [third_party library](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo). In the next sections we will create our own account contracts. 

2. Send funds to that address, eventhough it has no contract yet (it has not yet been deployed);

For example, we can send funds using the [testnet faucet](https://faucet.goerli.starknet.io/).

3. The contract pays for its deloyment transaction if it passes `__validate_deploy__`; and 

Deploy the account contract with:

```Bash
starknet deploy_account --network alpha-goerli --account ALIAS --wallet starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
```

If the conditions defined in the `__validate_deploy__` entrypoint are met, the account contract is deployed. In the case of the Open Zeppelin account contract the signature should be valid for the contract to be deployed:

```Bash
@external
func __validate_deploy__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(class_hash: felt, contract_address_salt: felt, _public_key: felt) {
    let (tx_info) = get_tx_info();
    is_valid_signature(tx_info.transaction_hash, tx_info.signature_len, tx_info.signature);
    return ();
}
```

4. The account contract is deployed ([Martin Triay, (Devcon 6)](https://www.youtube.com/watch?v=Osc_gwNW3Fw)).

If successfully deployed, we get:

```Bash
Sending the transaction with max_fee: 0.000000 ETH (323076307108 WEI).
Sent deploy account contract transaction.

Contract address: 0x006b27f2455d175f1c9b39568838ee0c1dfba34ca29f489690e40ee69220f15c
Transaction hash: 0x3dc6e579d7b4204907de859d1a12e42132853b9827e7203487740d51e957eed
```

Please note currently the StarkNet CLI only works with the [OpenZeppelin account contract](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo). If we want to deploy our own account contracts we need to deploy them using a different method. More on the next sections. 

Now we will examine the inner workings of the Open Zeppelin contract and proceed create our own account contracts.

### Using the Open Zeppelin standards

Although account contracts are nothing more than smart contracts, they have methods that set them apart from other smart contracts. This is the [Open Zeppelin IAccount contract interface](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.4.0b/src/openzeppelin/account/IAccount.cairo) adopted also by Argent (it implements [EIP-1271](https://eips.ethereum.org/EIPS/eip-1271)):

```Rust
struct Call {
    to: felt,
    selector: felt,
    calldata_len: felt,
    calldata: felt*,
}

// Tmp struct introduced while we wait for Cairo to support passing `[Call]` to __execute__
struct CallArray {
    to: felt,
    selector: felt,
    data_offset: felt,
    data_len: felt,
}


@contract_interface
namespace IAccount {
    func supportsInterface(interfaceId: felt) -> (success: felt) {
    }

    func isValidSignature(hash: felt, signature_len: felt, signature: felt*) -> (isValid: felt) {
    }

    func __validate__(
        call_array_len: felt, call_array: AccountCallArray*, calldata_len: felt, calldata: felt*
    ) {
    }

    func __validate_declare__(class_hash: felt) {
    }

    func __execute__(
        call_array_len: felt, call_array: AccountCallArray*, calldata_len: felt, calldata: felt*
    ) -> (response_len: felt, response: felt*) {
    }
}
```

And this is the public API ([find the complete preset here](https://github.com/OpenZeppelin/cairo-contracts/blob/release-v0.4.0b/src/openzeppelin/account/presets/Account.cairo)):

```Rust
namespace Account {
    func constructor(publicKey: felt) {
    }

    func getPublicKey() -> (publicKey: felt) {
    }

    func supportsInterface(interfaceId: felt) -> (success: felt) {
    }

    func setPublicKey(newPublicKey: felt) {
    }

    func isValidSignature(hash: felt, signature_len: felt, signature: felt*) -> (isValid: felt) {
    }

    func __validate__(
        call_array_len: felt, call_array: AccountCallArray*, calldata_len: felt, calldata: felt*
    ) -> (response_len: felt, response: felt*) {
    }

    func __validate_declare__(
        call_array_len: felt, call_array: AccountCallArray*, calldata_len: felt, calldata: felt*
    ) -> (response_len: felt, response: felt*) {
    }

    func __execute__(
        call_array_len: felt, call_array: AccountCallArray*, calldata_len: felt, calldata: felt*
    ) -> (response_len: felt, response: felt*) {
}
```

Note that the [default account contract](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo) used by StarkNet and mainly developed by Open Zeppelin has this same structure.

Let's examine the entry points (functions):

* `constructor`: It is not a requirement.
  * `publicKey: felt`: While the interface is agnostic of signature validation schemes, this implementation assumes thereâ€™s a public-private key pair controlling the Account. Thatâ€™s why the constructor function expects a `public_key` parameter to set it. Since thereâ€™s also a `setPublicKey()` method, accounts can be effectively transferred ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
* `getPublicKey`: Returns the public key associated with the Account ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
* `supportsInterface`: Returns TRUE if this contract implements the interface defined by `interfaceId`. Account contracts now implement ERC165 through static support (see [Account differentiation with ERC165](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts#account_differentiation_with_erc165)) ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
* `setPublicKey`: Sets the public key that will control this Account. It can be used to rotate keys for security, change them in case of compromised keys or even transferring ownership of the account ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
* `isValidSignature`: This function is inspired by EIP-1271 and returns TRUE if a given signature is valid, otherwise it reverts. In the future it will return FALSE if a given signature is invalid ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
* `__validate__`: Allows you to define an arbitrary logic to determine if a transaction is valid or not. They can not read other contracts storage, this helps as anti-spam. For example, a lot of transactions can depend on the storage of a contract, therefore if the storage changes then everything that depends on it start failing. The account contract will first call `__validate__` upon receiving a transaction. It receives as arguments (calldata):
  * `call_array_len: felt` - number of calls.
  * `call_array: AccountCallArray*` - array representing each `Call`.
  * `calldata_len: felt` - number of calldata parameters. Remember calldata are the arguments used to call a function.
  * `calldata: felt*` - array representing the function parameters.
* `__validate_declare__`: Validates the declaration signature prior to the declaration. As of Cairo v0.10.0, contract classes should be declared from an Account contract ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)). Declare transactions now require accounts to pay fees.
  * `class_hash: felt`:
* `__execute__`: This is the only external entrypoint to interact with the Account contract. If `__validate__` is successful `__execute__` will be called. Acts as the state-changing entry point for all user interaction with any contract, including managing the account contract itself ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).
  * Same arguments as `__validate__`. However, `__execute__` returns a transaction response.

We are also using new structs:
1. A single `Call`:

```Rust
struct Call {
    to: felt
    selector: felt
    calldata_len: felt
    calldata: felt*
}
```
Where:

* `to` is the address of the target contract of the message.
* `selector` is the selector of the function to be called on the target contract.
* `calldata_len` is the number of calldata parameters.
* `calldata` is an array representing the function parameters ([Open Zeppelin Docs, 2022](https://docs.openzeppelin.com/contracts-cairo/0.5.0/accounts)).


2. `AccountCallArray`, a calls array:

```Rust
struct AccountCallArray {
    to: felt
    selector: felt
    data_offset: felt
    data_len: felt
}
```
Where:
* `to` and `selector` are the same as in `Call`.
* `data_offset` is the starting position of the calldata array that holds the `Call`'s calldata.
* `data_len` is the number of calldata elements in the `Call`.


### Understanding the Open Zeppelin account contract

As we saw before, Account Abstraction also means validation abstraction. In other words, the developer can select the best validation process for what she is building.

This is the main goal of the view `func isValidSignature(hash: felt, signature_len: felt, signature: felt*)` function, also named as `is_valid_signature`. Let's look at this function in the default Open Zeppelin contract:

```Rust
@view
func is_valid_signature{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(hash: felt, signature_len: felt, signature: felt*) -> () {
    let (_public_key) = public_key.read();

    // This interface expects a signature pointer and length to make
    // no assumption about signature validation schemes.
    // But this implementation does, and it expects a (sig_r, sig_s) pair.
    with_attr error_message("INVALID_SIGNATURE_LENGTH") {
        assert signature_len = 2;
    }

    let sig_r = signature[0];
    let sig_s = signature[1];

    verify_ecdsa_signature(
        message=hash, public_key=_public_key, signature_r=sig_r, signature_s=sig_s
    );

    return ();
}
```

Notice it accepts any signature schemes in thaks to the argument `signature: felt*`, however, in this implimentation it expects a `(sig_r, sig_s)` pair. Otherwise, it throws the `INVALID_SIGNATURE_LENGTH` error. Then the `verify_ecdsa_signature` function (from the `common.signature` library) verifies the signature. If everything goes well then the function will pass without error. For `verify_ecdsa_signature` to work, we need to provide the implicit argument `ecdsa_ptr` of type `SignatureBuiltin*`.

This function is used in all the account contract's functions that require signature validation: `__validate__`, `__validate_deploy__`, and `__validate_declare__`. These three functions have practically the same structure in the Open Zeppelin implementation; let's examine one:

```Rust
@external
func __validate__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(call_array_len: felt, call_array: CallArray*, calldata_len: felt, calldata: felt*) {
    let (tx_info) = get_tx_info();
    is_valid_signature(tx_info.transaction_hash, tx_info.signature_len, tx_info.signature);
    return ();
}
```

The function obtains the required transaction information with the `get_tx_info` function from the `common.syscalls` library. Then it validates with the previously defined `is_valid_signature` function. We provide the `ecdsa_ptr` implicit argument since `is_valid_signature` needs it. The Open Zeppelin implementation does not use the call information in the arguments. But will we explore them next. Let's examine the other key function, `__execute__`:

```Rust
@external
@raw_output
func __execute__{
    syscall_ptr: felt*, pedersen_ptr: HashBuiltin*, range_check_ptr, ecdsa_ptr: SignatureBuiltin*
}(call_array_len: felt, call_array: CallArray*, calldata_len: felt, calldata: felt*) -> (
    retdata_size: felt, retdata: felt*
) {
    alloc_locals;

    let (__fp__, _) = get_fp_and_pc();
    let (tx_info) = get_tx_info();


    let (caller) = get_caller_address();
    with_attr error_message(
            "Invalid caller. This function cannot be called from another contract.") {
        assert caller = ORIGIN_ADDRESS;
    }

    // Convert to call_array (of type CallArray*) to calls (of type Call*)
    let (calls: Call*) = alloc();
    from_call_array_to_call(call_array_len, call_array, calldata, calls);

    let calls_len = call_array_len;
    local multicall: MultiCall = MultiCall(
        tx_info.account_contract_address,
        calls_len,
        calls,
        tx_info.max_fee,
        tx_info.version
        );

    // Execute all the calls. Note that creating `multicall` was not necessary in this ocasion
    let (response: felt*) = alloc();
    let (response_len) = execute_list(multicall.calls_len, multicall.calls, response);

    return (retdata_size=response_len, retdata=response);
}
```
Let's go part by part.

First, note we are using the `@raw_output` decorator. It basically instructs the compiler not to process the functionâ€™s return value. In such a case, the functionâ€™s return values must be `retdata_size` and `retdata`; and they have to have that precise name.

We notice that only the account contract can call its own `__execute__` function. `get_caller_address()` will be 0 in this instance, and `ORIGIN_ADDRESS`, available in the `common.constants` library ([link](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/common/constants.cairo#L2)), is also 0. We assert their equality.

```Rust
    let (caller) = get_caller_address();
    with_attr error_message(
            "Invalid caller. This function cannot be called from another contract.") {
        assert caller = ORIGIN_ADDRESS;
    }
```

We define an array of `Call`s, `calls`, where we will be storing all the calls that we want to execute. We use the internal `from_call_array_to_call` function [defined in the same contract](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo#L259) to move the array of `CallArray`s that we received in the arguments to the `calls` array. This is a temporary solution that will improve in next versions.

```Rust 
    // Convert to call_array (of type CallArray*) to calls (of type Call*)
    let (calls: Call*) = alloc();
    from_call_array_to_call(call_array_len, call_array, calldata, calls);
```

This account contract works with multicalls. That is, it can perform several calls in a single execution. Think in the concept of creating a shopping cart of items you will buy together in a single click, against having to buy each item one by one. For this, we create a `MultiCall` struct that contains the information required to make a call, including: the account address to which we will call, and the actual calls (they include the selector of the function and the calldata).


```Rust
    // Get the number of calls which is equal to the number of "CallArray"s we had.
    let calls_len = call_array_len;

    // Defines a new struct MultiCall with all the info on our call
    local multicall: MultiCall = MultiCall(
        tx_info.account_contract_address,
        calls_len,
        calls,
        tx_info.max_fee,
        tx_info.version
        );
```

Finally, we execute the list of calls and store the responses in a `felt` array, `response`. In this case, creating the `multicall` struct was innecesary since we could have directly sent the `execute_list` function ([defined in the same contract](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo#L232)) the `calls` array. However, in other ocasion, having `multicall` would have been useful, it is better to have the tools at hand.

```Rust
    // Execute all the calls. Note that creating `multicall` was not necessary in this ocasion
    let (response: felt*) = alloc();
    let (response_len) = execute_list(multicall.calls_len, multicall.calls, response);

    return (retdata_size=response_len, retdata=response);
```

There is nothing complicated in the default Open Zeppelin account contract, yet it shows the main functionality of account abstraction. Now we will see how deploying it looks like.


### Counterfactual deployment from the inside (optional)

Let us deploy the default account contract, inspired by the Open Zeppelin implementation, with alias `second-account`, to the Goerli 2 testnet. The  `--wallet starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount` flag indicates we will use the default account contract, currently we can only use this contract with the CLI.

```Bash
starknet new_account --feeder_gateway_url https://alpha4-2.starknet.io --gateway_url https://alpha4-2.starknet.io --network_id 1536727068981429685321 --account second-account --wallet starkware.starknet.wallets.open_zeppelin.OpenZeppelinAccount
```

We get:

```Bash
Account address: 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9
Public key: 0x066ed5a84f995a2dcd714b505dc165a8df71473ebc374dbe5fe973631198ba72
Move the appropriate amount of funds to the account, and then deploy the account
by invoking the 'starknet deploy_account' command.

NOTE: This is a modified version of the OpenZeppelin account contract. The signature is computed
differently.
```

[OPTIONAL] We can go deeper into examining the default Open Zeppelin account contract to get the class hash, salt and constructor calldata that are used to calculate its address. [`contract_address.py`](utils/contract_address.py) is a copy of the [`contract_address.py`](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/core/os/contract_address/contract_address.py) library from the Starkware library. We added print statements in the `calculate_contract_address()` function to get the class hash, salt, and constructor calldata. If you wish to use it, go to where your OS stores your Python packages (likely `site-packages`) and replace `/starkware/starknet/core/os/contract_address/contract_address.py` with our [`contract_address.py`](utils/contract_address.py). Then, when we defined our account contract with `starknet new_account ...` we also get:

```Bash
Class Hash: 895370652103566112291566439803611591116951595367594863638369163604569619773
Salt: 462250451139519919709009935198618602877233823783070820758189518720702799406
Constructor calldata: [2909704878250883580952868877137725986814034606621060536770963048574421088882]
```

All three properties are in felt format. You can manually convert them into their hex representations, if you wish, with the [stark-utils](https://www.stark-utils.xyz/converter) converter. The Open Zeppelin default account contract requires a public key in its constructor ([see implementation](https://github.com/starkware-libs/cairo-lang/blob/master/src/starkware/starknet/third_party/open_zeppelin/Account.cairo#L105)), if we wish, with our own account contracts, we can not add this requirement. The contract we defined above has a public key `0x066ed5a84f995a2dcd714b505dc165a8df71473ebc374dbe5fe973631198ba72` once we converted the above felt into hex format.

Calculating the address is the key of this first step in counterfactual deployment. Remember, it has not yet been deployed, we only calculated the address and added this new account to the `.starknet_accounts/starknet_open_zeppelin_accounts.json` file. It is key to closely follow the `starknet_open_zeppelin_accounts.json` since there we can find our created account contracts; you will find it in your root directory, for example, `/Users/espejelomar/.starknet_accounts/starknet_open_zeppelin_accounts.json`. `starknet_open_zeppelin_accounts.json` shows relevant information for the creation of each account contract. For example, for the `first-account` we created previously we have:

```Bash
"1536727068981429685321": {
        "second-account": {
            "private_key": "XXX",
            "public_key": "0x66ed5a84f995a2dcd714b505dc165a8df71473ebc374dbe5fe973631198ba72",
            "salt": "0x1059fde2a4da7c421dd6dbe8af873a2977c6008c7a09e61db1c5a45d25ede2e",
            "address": "0x2b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9",
            "deployed": false
        }
    },
```
`1536727068981429685321` is the chain_id for goerli. Note it says `"deployed": false` since we have not deployed the contract. 

If we use the same compiled code, salt (this is the main function of the salt), and constructor call data then we should be able to calculate the same address. The `get_address` function in [`accounts_abstraction_utils.py`](utils/accounts_abstraction_utils.py) (next step: create a new library for helping users more easily create account contracts ðŸš€) is able to calculate the address of any contract without deploying it. We will get the same address for the Open Zeppelin account contract if we get into Python mode in our terminal, `python3.9 -i utils/accounts_abstraction_utils.py` (I am using `python 3.9`), and call (notice we reuse the `salt` and `constructor_calldata` we got above, and that we are using the compiled code of the default Open Zeppelin account contract in [`assets/compiled_open_zeppeling_account_contract.json`](../../../assets/compiled_open_zeppeling_account_contract.json).

```Python
get_address(
    contract_path_and_name = "assets/compiled_open_zeppeling_account_contract.json",
    salt = 462250451139519919709009935198618602877233823783070820758189518720702799406,
    constructor_calldata = [2909704878250883580952868877137725986814034606621060536770963048574421088882],
    deployer_address = 0,
    compiled = True,
)
```

We get:

```Bash
Account contract address: 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9
Class contract hash: 0x01fac3074c9d5282f0acc5c69a4781a1c711efea5e73c550c5d9fb253cf7fd3d
Salt: 0x01059fde2a4da7c421dd6dbe8af873a2977c6008c7a09e61db1c5a45d25ede2e
Constructor call data: [2909704878250883580952868877137725986814034606621060536770963048574421088882]

Move the appropriate amount of funds to the account. Then deploy the account.
```

Everything matches, including the account contract address, to our calculation using `starknet new_account ...`. Great! We now know how we are able to calculate addresses before deploying. This is the most important part of counter factual deployment.

Let's fund the calculated address. We can do this by bridging Goerli ETH from L1 to Goerli 2 in the L2. First, fund your L1 wallet with Goerli ETH (you can use the [Paradigm faucet](https://faucet.paradigm.xyz/api/auth/signin)). Now go into the [Goerli 2 contract in the L1](https://goerli.etherscan.io/address/0xaea4513378eb6023cf9ce730a26255d0e3f075b9#writeProxyContract) and in the external `deposit` function write the amount of ETH you wish to bridge and L2 recipient (our calculated contract address: 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9). Now this contract can pay for its own deployment.

We deploy the account contract to Goerli 2 using Protostar. Add (1) as input the constructor calldata, and (2) as salt our value we had before. If we do not specificate the salt value then Protostar generates a random value and we wonÂ´t deploy into our defined contract address.

```Bash
protostar deploy assets/compiled_open_zeppeling_account_contract.json --inputs 2909704878250883580952868877137725986814034606621060536770963048574421088882 --salt 462250451139519919709009935198618602877233823783070820758189518720702799406 --gateway-url https://alpha4-2.starknet.io --chain-id 1536727068981429685321
```

We get:

```Bash
[INFO] Deploy transaction was sent.
Contract address: 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9
Transaction hash: 0x070326e2bed2746fe92847eacf9d04a05cf7b943369afb99f4ad09839f0281c0
```

The contract address is still the same. And now our contract is [deployed in Goerli 2](https://testnet-2.starkscan.co/contract/0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9#overview). Inside StarkScan go to the Portfolio tab to see the ETH we transferred to this address before the deployment.

Let's initiate a transaction with the account contract we deployed. We will call the `get_voting_status()` `view` function from the voting contract we deployed in a previous session. This function will simply show us the status of an on-chain vote.

In this camp's utils we wrote the [account_abstraction_utils.py](utils/accounts_abstraction_utils.py) toolkit. The `sign_invoke_transaction` function is a generalization (well, an abstraction) of the [`sign_invoke_tx`](https://github.com/starkware-libs/cairo-lang/blob/f951a669e264796d53bf7a3cfd23d5bc1f6e54b8/src/starkware/starknet/wallets/open_zeppelin.py#L306) function used by the default Open Zeppelin account contract implementation. In the next sections we will use `sign_invoke_transaction` for signing transactions with different types of account contracts. You can find the complete and commented version in this camp's utils, we will go over a non-documented version of it here:

```Python
async def sign_invoke_transaction(
    contract_address_to_invoke: int,
    function_name: str,
    calldata: Sequence[int],
    signer_address: int,
    private_key: Optional[int],
    version: Optional[int] = 1,
    chain_id: int = TESTNET_ID,
    max_fee: Optional[int] = MAX_FEE,
    gateway_url: str = "https://alpha4-2.starknet.io",
):
    """
    Given a function to invoke (contract address, selector, calldata) and the account contract's identifiers
    (signer address, possibly private key) prepares and signs an account invocation to this
    function. The transaction will connect to the Testnet automatically with the `chain_id` argument.
    """

    data_offset = 0
    # How many inputs does the function's calldata asks for?
    data_len = len(calldata)
    # call_array follows the members of CallArray struct in our contract
    selector = get_selector_from_name(function_name)
    call_array = [contract_address_to_invoke, selector, data_offset, data_len]
    # call_array_len = 1, since we are only making a call
    call_array_len = 1
    calldata_len = len(calldata)
    # We need to provide __execute__ with the arguments:
    # call_array_len: felt, call_array: CallArray*, calldata_len: felt, calldata: felt*
    execute_calldata = [call_array_len, *call_array, calldata_len, *calldata]

    # Get account contract's nonce
    account_contract_nonce = int(
        os.popen(
            f"starknet get_nonce --contract_address 0x{signer_address:064x} --feeder_gateway_url {gateway_url} --gateway_url {gateway_url} --network_id 1536727068981429685321"
        ).read()
    )

    # Calculates the transaction hash in the StarkNet network - a unique identifier of the transaction
    # This is valuable only if we need to sign the transaction
    hash_value = calculate_transaction_hash_common(
        tx_hash_prefix=TransactionHashPrefix.INVOKE,
        version=version,
        contract_address=signer_address,
        entry_point_selector=0,
        calldata=execute_calldata,
        max_fee=max_fee,
        chain_id=chain_id,
        additional_data=[account_contract_nonce],
    )

    # If there is a private key then we sign the transaction
    if private_key is None:
        signature = []
    else:
        signature = list(sign(msg_hash=hash_value, priv_key=private_key))

    # execute_calldata contains the calldata of the __execute__ function in the account contract
    invoke_function = InvokeFunction(
        contract_address=signer_address,
        calldata=execute_calldata,
        max_fee=max_fee,
        nonce=account_contract_nonce,
        signature=signature,
        version=version,
    )

    local_network_client = GatewayClient(gateway_url)

    gateway_response = await local_network_client.send_transaction(invoke_function)
```

`sign_invoke_transaction` basically goes trough the necessary steps to sign a transaction with an account contract. All the arguments make sense. Particularly: 

```Python
    contract_address_to_invoke: int,
    function_name: str,
    calldata: Sequence[int],
    signer_address: int,
    private_key: Optional[int],
```

Notice how the private key is optional since in alternative account contract implementations signature validation could not use a private key.

There are two key insights we can understand from the above implementation:
1. The creation of the `call_array` Python list. We fill `call_array` with the members of the `CallArray` Cairo struct in the contract: `to: felt, selector: felt, data_offset: felt, data_len: felt`.
2. The creation of the `execute_calldata` Python list. We fill `execute_calldata` with the calldata (arguments) for the `__execute__` function in contract: `call_array_len: felt, call_array: CallArray*, calldata_len: felt, calldata: felt*`

Notice that in Python an asterisk, `*`, before a list means we are [unpacking it](https://note.nkmk.me/en/python-tuple-list-unpack/).

What is a nonce? A sequential number attached to the account contract, that prevents transaction replay and guarantees the order of execution and uniqueness of the transaction hash.

Let's use the `sign_invoke_transaction` function to call the `get_voting_status` view function from a voting contract (address [`0x07D960D57C020BE3BDDBA01FCE139800590BAF8E58B8ABDB7B45BDF518B0A16E`](https://testnet-2.starkscan.co/contract/0x07d960d57c020be3bddba01fce139800590baf8e58b8abdb7b45bdf518b0a16e#read-contract)).

```Python
async def main():

    await sign_invoke_transaction(
        contract_address_to_invoke=0x07D960D57C020BE3BDDBA01FCE139800590BAF8E58B8ABDB7B45BDF518B0A16E,
        function_name="get_voting_status",
        calldata=[],
        signer_address=0x2B0FC135CAE406BBC27766C189972DD3AAE5FC79A66D5191A8D6AC76A0CE8F9,
        private_key=0x7398FB40A1C5B537D97D1E8ED9439B3A3807F02814DDF501C7521AB84E5B4A7,
    )

asyncio.run(main())
```

The output in our shell is:

```Bash
Transaction hash: 0x050d6974e229226c35683885c446c5c0d397b4b5f2091180bb88a3398a5855bd
Status: TRANSACTION_RECEIVED
Deployed at: https://alpha4-2.starknet.io
Invoked contract address: 0x07d960d57c020be3bddba01fce139800590baf8e58b8abdb7b45bdf518b0a16e
Invoked function: get_voting_status 
Signer contract address: 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9
Signer contract nonce: 1
```

We can review our transaction in a [block explorer](https://testnet-2.starkscan.co/tx/0x050d6974e229226c35683885c446c5c0d397b4b5f2091180bb88a3398a5855bd). Notice that if we make the same invoke, with the same account contract as signer, then the nonce will increase by 1.

Great! Now we dominate the Open Zeppelin account contract, how to counterfactually deploy it, and how to make invoke calls with it as signer.

*********
**WIP** DISREGARD THE FOLLOWING
*********


### Examples



This returns a `0`. 

Deploy the voting contract with the contract we deployed as an admin and unique voter.

```Bash
protostar deploy build/vote.json --inputs 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9 1 0x02b0fc135cae406bbc27766c189972dd3aae5fc79a66d5191a8d6ac76a0ce8f9 --gateway-url https://alpha4-2.starknet.io --chain-id 1536727068981429685321
```

We get:

```Bash
Contract address: 0x07d960d57c020be3bddba01fce139800590baf8e58b8abdb7b45bdf518b0a16e
Transaction hash: 0x05c8b2a41b0d8fe7dccfa0cfe7be0281e2de22b3ba2dffd0a64c259b45e67171
```

Let's invoke with our new account contract.

```Python
sign_invoke_transaction(
    contract_address=0x07D960D57C020BE3BDDBA01FCE139800590BAF8E58B8ABDB7B45BDF518B0A16E,
    function_name="admin",
    calldata=[],
    signer_address=0x2B0FC135CAE406BBC27766C189972DD3AAE5FC79A66D5191A8D6AC76A0CE8F9,
    private_key=0x7398FB40A1C5B537D97D1E8ED9439B3A3807F02814DDF501C7521AB84E5B4A7,
)
```

Unlike Ethereum [EOAs](https://ethereum.org/en/developers/docs/accounts/#externally-owned-accounts-and-key-pairs), StarkNet accounts don't have a hard requirement on being managed by a public/private key pair.

AA cares more about `who`(i.e. the contract address) rather than `how`(i.e. the signature).

This leaves the ECDSA signature scheme up to the developer and is typically implemented using the [pedersen hash](https://docs.starknet.io/docs/Hashing/hash-functions) and native Stark curve:

The `signature_1` contract has no concept of a public/private keypair. All the signing was done "off-chain" and yet with AA we're still able to operate a functioning account with a populated signature field.




.
.
.
.
.



Unlike Ethereum where accounts are directly derived from a private key, thereâ€™s no native account concept on StarkNet.

Instead, signature validation has to be done at the contract level. To relieve smart contract applications such as ERC20 tokens or exchanges from this responsibility, we make use of Account contracts to deal with transaction authentication.


<h2 align="center" id="l1l2">L1-L2 Messaging</h2>


<hr>